{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "src/animate/Animator.js",
    "src/animate/AnimatorTimeline.js",
    "src/animate/MovieClip.js",
    "src/animate/ShapesCache.js",
    "src/animate/SymbolLoader.js",
    "src/animate/Timeline.js",
    "src/animate/Tween.js",
    "src/animate/index.js",
    "src/animate/load.js",
    "src/animate/utils.js",
    "src/mixins/Container.js",
    "src/mixins/DisplayObject.js",
    "src/mixins/Graphics.js",
    "src/mixins/Sprite.js",
    "src/mixins/Text.js",
    "src/mixins/index.js",
    "index.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import AnimatorTimeline from './AnimatorTimeline';\nconst SharedTicker = PIXI.ticker.shared;\n\nconst timelines = [];\n\n/**\n * Play animation via start/stop frame labels\n * @class Animator\n * @namespace PIXI.animate\n */\nclass Animator {\n\n    /**\n     * The collection of timelines\n     * @property {Array<PIXI.animate.AnimatorTimeline>} _timelines\n     * @private\n     * @static\n     */\n    static get _timelines() {\n        return timelines;\n    }\n\n    /**\n     * Suffix added to label for a stop.\n     * @property {String} STOP_LABEL\n     * @static\n     * @default \"_stop\"\n     */\n    static get STOP_LABEL() {\n        return \"_stop\";\n    }\n\n    /**\n     * Suffix added to label for a loop.\n     * @property {String} LOOP_LABEL\n     * @static\n     * @default \"_loop\"\n     */\n    static get LOOP_LABEL() {\n        return \"_loop\";\n    }\n\n    /**\n     * Play an animation by\n     * @method play\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String} event The frame label event to call\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static play(instance, event, callback) {\n        var startLabel, endLabel, loop = false;\n\n        for (var i = 0, len = instance.labels.length; i < len; i++) {\n            var label = instance.labels[i];\n            if (label.label === event) {\n                startLabel = label;\n            } else if (label.label === event + this.STOP_LABEL) {\n                endLabel = label;\n            } else if (label.label === event + this.LOOP_LABEL) {\n                loop = true;\n                endLabel = label;\n            }\n\n            if (startLabel && endLabel) {\n                break;\n            }\n        }\n\n        if (!startLabel) {\n            throw new Error(\"No start label matching '\" + event + \"'\");\n        } else if (!endLabel) {\n            throw new Error(\"No end label matching '\" + event + \"'\");\n        }\n\n        // Stop any animation that's playing\n        this.stop(instance);\n\n        // Add a new timeline\n        const timeline = AnimatorTimeline.create(\n            instance,\n            loop,\n            startLabel.position,\n            endLabel.position,\n            callback\n        );\n        this._timelines.push(timeline);\n\n        // Set the current frame\n        if (instance.currentFrame !== startLabel.position) {\n            instance.gotoAndPlay(event);\n        } else {\n            instance.play();\n        }\n        this._refresh();\n\n        return timeline;\n    }\n\n    /**\n     * Stop the animation\n     * @method stop\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     */\n    static stop(instance) {\n        for (var i = 0, len = this._timelines.length; i < len; i++) {\n            var timeline = this._timelines[i];\n            if (timeline.instance === instance) {\n                this._internalStop(timeline);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Stop the animation\n     * @method _internalStop\n     * @private\n     * @static\n     * @param {PIXI.animate.AnimatorTimeline} timeline Timeline to stop.\n     */\n    static _internalStop(timeline) {\n        this._timelines.splice(this._timelines.indexOf(timeline), 1);\n        timeline.instance.stop();\n        timeline.destroy();\n        this._refresh();\n    }\n\n    /**\n     * Refresh if we should be updating\n     * @method _refresh\n     * @private\n     * @static\n     */\n    static _refresh() {\n        if (this._updateBind) {\n            SharedTicker.remove(this._updateBind);\n        }\n        this._updateBind = this._update.bind(this);\n        if (this._timelines.length > 0) {\n            SharedTicker.add(this._updateBind);\n        }\n    }\n\n    /**\n     * Update the animation\n     * @method _update\n     * @static\n     * @private\n     */\n    static _update() {\n        for (var i = this._timelines.length - 1; i >= 0; i--) {\n            this._timelines[i].update();\n        }\n    }\n}\n\nmodule.exports = Animator;",
    "const pool = [];\n\n/**\n * Represents a single animation play.\n * @class AnimatorTimeline\n * @namespace PIXI.animate\n */\nclass AnimatorTimeline {\n    constructor() {\n        this.init(null, null, false, 0, 0);\n    }\n\n    /**\n     * The pool of timelines to use\n     * @method init\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Boolean} loop\n     * @param {Number} start\n     * @param {Number} init\n     * @private\n     */\n    init(instance, loop, start, end, callback) {\n        this.instance = instance;\n        this.loop = loop;\n        this.start = start;\n        this.end = end;\n        this.callback = callback;\n\n        if (instance) {\n            instance.gotoAndStop(start);\n        }\n    }\n\n    /**\n     * Don't use after this\n     * @method destroy\n     * @private\n     */\n    destroy() {\n        this.init(null, null, false, 0, 0, null);\n        AnimatorTimeline._pool.push(this);\n    }\n\n    /**\n     * Is the animation complete\n     * @method update\n     * @return {Boolean} \n     * @private\n     */\n    update() {\n        if (this.instance.currentFrame >= this.end) {\n            if (this.loop) {\n                this.instance.gotoAndPlay(this.start);\n            } else {\n                var callback = this.callback;\n                this.stop();\n                if (callback) {\n                    callback();\n                }\n            }\n        }\n    }\n\n    /**\n     * Stop the animation, cannot be reused.\n     * @method stop\n     */\n    stop() {\n        PIXI.animate.Animator._internalStop(this);\n    }\n\n    /**\n     * The progress from 0 to 1 of the playback.\n     * @property {Number} progress\n     * @readOnly\n     */\n    get progress() {\n        const progress = (this.instance.currentFrame - this.start) / (this.end - this.start);\n        return Math.max(0, Math.min(1, progress)); // clamp\n    }\n\n    /**\n     * The pool of timelines to use\n     * @property {Array<AnimatorTimeline>} _pool\n     * @static\n     * @private\n     */\n    static get _pool() {\n        return pool;\n    }\n\n    /**\n     * Create a new timeline\n     * @method create\n     * @static\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Boolean} loop\n     * @param {Number} start\n     * @param {Number} init\n     * @param {Function} callback\n     * @return {PIXI.animate.AnimatorTimeline}\n     */\n    static create(instance, loop, start, end, callback) {\n        var timeline;\n        if (this._pool.length) {\n            timeline = this._pool.pop();\n        } else {\n            timeline = new AnimatorTimeline();\n        }\n        timeline.init(instance, loop, start, end, callback);\n        return timeline;\n    }\n}\n\nmodule.exports = AnimatorTimeline;",
    "import Timeline from './Timeline';\nimport utils from './utils';\n\nconst Container = PIXI.Container;\nconst SharedTicker = PIXI.ticker.shared;\n\n/**\n * Provide timeline playback of movieclip\n * @namespace PIXI.animate\n * @class MovieClip\n * @extends PIXI.Container\n * @constructor\n * @param {Object|int} [options] The options object or the mode to play\n * @param {int} [options.mode=0] The playback mode default is independent (0),\n * @param {int} [options.startPosition=0] The starting frame\n * @param {Boolean} [options.loop=true] If playback is looped\n * @param {Object} [options.labels] The frame labels map of label to frames\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\n * @param {int} [options.framerate=24] The framerate to use for independent mode\n */\nclass MovieClip extends Container {\n    constructor(options, duration, loop, framerate, labels) {\n        super();\n\n        // Default options\n        options = options === undefined ? {} : options;\n\n        // Options can also be the mode\n        if (typeof options === 'number') {\n            options = {\n                mode: options || MovieClip.INDEPENDENT,\n                duration: duration || 0,\n                loop: loop === undefined ? true : loop,\n                labels: labels || {},\n                framerate: framerate || 0,\n                startPosition: 0\n            };\n        } else {\n            // Apply defaults to options\n            options = Object.assign({\n                mode: MovieClip.INDEPENDENT,\n                startPosition: 0,\n                loop: true,\n                labels: {},\n                duration: 0,\n                framerate: 0\n            }, options);\n        }\n\n        /**\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n         * See each constant for a description of the behaviour.\n         * @property mode\n         * @type int\n         * @default null\n         */\n        this.mode = options.mode;\n\n        /**\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n         * @property startPosition\n         * @type Number\n         * @default 0\n         */\n        this.startPosition = options.startPosition;\n\n        /**\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n         * @property loop\n         * @type Boolean\n         * @default true\n         */\n        this.loop = !!options.loop;\n\n        /**\n         * The current frame of the movieclip.\n         * @property currentFrame\n         * @type Number\n         * @default 0\n         * @readOnly\n         */\n        this.currentFrame = 0;\n\n        this._labels = [];\n        this._labelDict = options.labels;\n        if (options.labels) {\n            for (let name in options.labels) {\n                let label = {\n                    label: name,\n                    position: options.labels[name]\n                };\n                this._labels.push(label);\n            }\n            this._labels.sort(function(a, b) {\n                return a.position - b.position;\n            });\n        }\n\n        /**\n         * If true, this movieclip will animate automatically whenever it is on the stage.\n         * @property selfAdvance\n         * @type Boolean\n         * @default true\n         */\n        this.selfAdvance = true;\n\n        /**\n         * If true, the MovieClip's position will not advance when ticked.\n         * @property paused\n         * @type Boolean\n         * @default false\n         */\n        this.paused = false;\n\n        /**\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n         * @property actionsEnabled\n         * @type Boolean\n         * @default true\n         */\n        this.actionsEnabled = true;\n\n        /**\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n         * <br><br>\n         * For example, if you had a character animation with a 'body' child MovieClip instance\n         * with different costumes on each frame, you could set body.autoReset = false, so that\n         * you can manually change the frame it is on, without worrying that it will be reset\n         * automatically.\n         * @property autoReset\n         * @type Boolean\n         * @default true\n         */\n        this.autoReset = true;\n\n        /**\n         * @property _synchOffset\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._synchOffset = 0;\n\n        /**\n         * @property _prevPos\n         * @type Number\n         * @default -1\n         * @private\n         */\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\n        /**\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\n         * elapsed from frame 0 in seconds.\n         * @property _t\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._t = 0;\n\n        /**\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n         * framerate.\n         *\n         * @property _framerate\n         * @type {Number}\n         * @default 0\n         */\n        this._framerate = options.framerate;\n\n        /**\n         * The total time in seconds for the animation. This is changed when setting the framerate.\n         * @property _duration\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._duration = 0;\n\n        /**\n         * The total duration in frames for the animation.\n         * @property _totalFrames\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._totalFrames = options.duration;\n\n        /**\n         * Standard tween timelines for all objects. Each element in the _timelines array\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\n         * @property _timelines\n         * @type Array\n         * @protected\n         */\n        this._timelines = [];\n\n        /**\n         * Array of child timelines denoting if a child is actively a child of this movieclip\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\n         * property, and is an array of boolean values indexed by frame.\n         * @property _timedChildTimelines\n         * @type {Array}\n         * @protected\n         */\n        this._timedChildTimelines = [];\n\n        /**\n         * Array to depth sort timed children\n         * @property _depthSorted\n         * @type {Array}\n         * @private\n         */\n        this._depthSorted = [];\n\n        /**\n         * Array of frame scripts, indexed by frame.\n         * @property _actions\n         * @type {Array}\n         * @protected\n         */\n        this._actions = [];\n\n        if (this.mode === MovieClip.INDEPENDENT) {\n            this._tickListener = this._tickListener.bind(this);\n            this._onAdded = this._onAdded.bind(this);\n            this._onRemoved = this._onRemoved.bind(this);\n            this.on('added', this._onAdded);\n            this.on('removed', this._onRemoved);\n        }\n\n        if (options.framerate) {\n            this.framerate = options.framerate;\n        }\n    }\n\n    _onAdded() {\n        SharedTicker.add(this._tickListener);\n    }\n\n    _tickListener(tickerDeltaTime) {\n        if (this.paused || !this.selfAdvance) {\n            //see if the movieclip needs to be updated even though it isn't animating\n            if (this._prevPos < 0) {\n                this._goto(this.currentFrame);\n            }\n            return;\n        }\n        let seconds = tickerDeltaTime / SharedTicker.speed / PIXI.TARGET_FPMS / 1000;\n        this.advance(seconds);\n    }\n\n    _onRemoved() {\n        SharedTicker.remove(this._tickListener);\n    }\n\n    /**\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n     * @property labels\n     * @type {Array}\n     * @readonly\n     */\n    get labels() {\n        return this._labels;\n    }\n\n    /**\n     * Returns the name of the label on or immediately before the current frame.\n     * @property currentLabel\n     * @type {String}\n     * @readonly\n     */\n    get currentLabel() {\n        let labels = this._labels;\n        let current = null;\n        for (let i = 0, len = labels.length; i < len; ++i) {\n            if (labels[i].position <= this.currentFrame) {\n                current = labels[i].label;\n            } else {\n                break;\n            }\n        }\n        return current;\n    }\n\n    /**\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\n     * @property elapsedTime\n     * @type Number\n     * @default 0\n     * @public\n     */\n    get elapsedTime() {\n        return this._t;\n    }\n\n    set elapsedTime(value) {\n        this._t = value;\n    }\n\n    /**\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n     * framerate.\n     *\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n     * vary slightly between frames.\n     *\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\n     * @property framerate\n     * @type {Number}\n     * @default 0\n     */\n    get framerate() {\n        return this._framerate;\n    }\n    set framerate(value) {\n        if (value > 0) {\n            this._framerate = value;\n            this._duration = value ? this._totalFrames / value : 0;\n        } else {\n            this._framerate = this._duration = 0;\n        }\n    }\n\n    /**\n     * Get the total number of frames (duration) of this MovieClip\n     * @property totalFrames\n     * @type {Number}\n     * @default 0\n     * @readOnly\n     */\n    get totalFrames() {\n        return this._totalFrames;\n    }\n\n    /**\n     * Extend the timeline to the last frame.\n     * @method _autoExtend\n     * @private\n     * @param {int} endFrame\n     */\n    _autoExtend(endFrame) {\n        if (this._totalFrames < endFrame) {\n            this._totalFrames = endFrame;\n        }\n    }\n\n    /**\n     * Convert values of properties\n     * @method _parseProperties\n     * @private\n     * @param {Object} properties\n     */\n    _parseProperties(properties) {\n        // Convert any string colors to uints\n        if (typeof properties.t === 'string') {\n            properties.t = utils.hexToUint(properties.t);\n        } else if (typeof properties.v === 'number') {\n            properties.v = !!properties.v;\n        }\n    }\n\n    /**\n     * Get a timeline for a child, synced timeline.\n     * @method _getChildTimeline\n     * @private\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {PIXI.animate.Timeline}\n     */\n    _getChildTimeline(instance) {\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\n            if (this._timelines[i].target === instance) {\n                return this._timelines[i];\n            }\n        }\n        let timeline = new Timeline(instance);\n        this._timelines.push(timeline);\n        return timeline;\n    }\n\n    /**\n     * Add mask or masks\n     * @method addTimedMask\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    addTimedMask(instance, keyframes) {\n        for (let i in keyframes) {\n            this.addKeyframe(instance, {\n                m: keyframes[i]\n            }, parseInt(i, 10));\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\n        return this;\n    }\n\n    /**\n     * Shortcut alias for `addTimedMask`\n     * @method am\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    am(instance, keyframes) {\n        return this.addTimedMask(instance, keyframes);\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method addTween\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTween(instance, properties, startFrame, duration, ease) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addTween(properties, startFrame, duration, ease);\n        this._autoExtend(startFrame + duration);\n        return this;\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method addKeyframe\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addKeyframe(instance, properties, startFrame) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addKeyframe(properties, startFrame);\n        this._autoExtend(startFrame);\n        return this;\n    }\n\n    /**\n     * Alias for method `addTimedChild`\n     * @method at\n     * @return {PIXI.animate.MovieClip}\n     */\n    at(instance, startFrame, duration, keyframes) {\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\n    }\n\n    /**\n     * Add a child to show for a certain number of frames before automatic removal.\n     * @method addTimedChild\n     * @param {PIXI.DisplayObject} instance The clip to show\n     * @param {int} startFrame The starting frame\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTimedChild(instance, startFrame, duration, keyframes) {\n\n        if (startFrame === undefined) // jshint ignore:line\n        {\n            startFrame = 0;\n        }\n        if (duration === undefined || duration < 1) // jshint ignore:line\n        {\n            duration = this._totalFrames || 1;\n        }\n\n        // Add the starting offset for synced movie clips\n        if (instance.mode === MovieClip.SYNCHED) {\n            instance.parentStartPosition = startFrame;\n        }\n\n        //add tweening info about this child's presence on stage\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\n        //should be set back to frame 0\n        let timeline, i;\n        //get existing timeline\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\n            if (this._timedChildTimelines[i].target === instance) {\n                timeline = this._timedChildTimelines[i];\n                break;\n            }\n        }\n        //if there wasn't one, make a new one\n        if (!timeline) {\n            timeline = [];\n            timeline.target = instance;\n            this._timedChildTimelines.push(timeline);\n        }\n\n        // Fill the timeline with keyframe booleans\n        utils.fillFrames(timeline, startFrame, duration);\n\n        // Update the total frames if the instance extends our current\n        // total frames for this movieclip\n        if (this._totalFrames < startFrame + duration) {\n            this._totalFrames = startFrame + duration;\n        }\n\n        // Add the collection of keyframes\n        if (keyframes) {\n            if (typeof keyframes === \"string\") {\n                keyframes = utils.deserializeKeyframes(keyframes);\n            }\n            // Convert the keyframes object into\n            // individual properties\n            let lastFrame = {};\n            for (let i in keyframes) {\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\n            }\n            this._getChildTimeline(instance)\n                .extendLastFrame(startFrame + duration);\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\n\n        return this;\n    }\n\n    /**\n     * Short cut for `addAction`\n     * @method aa\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    aa(callback, startFrame) {\n        return this.addAction(callback, startFrame);\n    }\n\n    /**\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\n     * @method addAction\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    addAction(callback, startFrame) {\n\n        if (typeof startFrame === 'string') {\n            const index = this._labelDict[startFrame];\n            if (index === undefined) {\n                throw `The label '${startFrame}' does not exist on this timeline`;\n            }\n            startFrame = index;\n        }\n\n        let actions = this._actions;\n        //ensure that the movieclip timeline is long enough to support the target frame\n        if (actions.length <= startFrame) {\n            actions.length = startFrame + 1;\n        }\n        if (this._totalFrames < startFrame) {\n            this._totalFrames = startFrame;\n        }\n        //add the action\n        if (actions[startFrame]) {\n            actions[startFrame].push(callback);\n        } else {\n            actions[startFrame] = [callback];\n        }\n        return this;\n    }\n\n    /**\n     * Sets paused to false.\n     * @method play\n     */\n    play() {\n        this.paused = false;\n    }\n\n    /**\n     * Sets paused to true.\n     * @method stop\n     */\n    stop() {\n        this.paused = true;\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to false.\n     * @method gotoAndPlay\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     */\n    gotoAndPlay(positionOrLabel) {\n        this.paused = false;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to true.\n     * @method gotoAndStop\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\n     */\n    gotoAndStop(positionOrLabel) {\n        this.paused = true;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Advances the playhead. This occurs automatically each tick by default.\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\n     * @method advance\n     */\n    advance(time) {\n        if (!this._framerate) {\n            let o = this,\n                fps = o._framerate;\n            while ((o = o.parent) && !fps) {\n                if (o.mode === MovieClip.INDEPENDENT) {\n                    fps = o._framerate;\n                }\n            }\n            this.framerate = fps;\n        }\n\n        if (time) {\n            this._t += time;\n        }\n        if (this._t > this._duration) {\n            this._t = this.loop ? this._t - this._duration : this._duration;\n        }\n        //add a tiny amount to account for potential floating point errors\n        this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\n        //final error checking\n        if (this.currentFrame >= this._totalFrames) {\n            this.currentFrame = this._totalFrames - 1;\n        }\n        //update all tweens & actions in the timeline\n        this._updateTimeline();\n    }\n\n    /**\n     * @method _goto\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     * @protected\n     */\n    _goto(positionOrLabel) {\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\n        if (pos === undefined) // jshint ignore:line\n        {\n            return;\n        }\n        // prevent _updateTimeline from overwriting the new position because of a reset:\n        this._prevPos = NaN;\n        this.currentFrame = pos;\n        //update the elapsed time if a time based movieclip\n        if (this._framerate > 0) {\n            this._t = pos / this._framerate;\n        } else {\n            this._t = 0;\n        }\n        this._updateTimeline();\n    }\n\n    /**\n     * @method _reset\n     * @private\n     */\n    _reset() {\n        this._prevPos = -1;\n        this._t = 0;\n        this.currentFrame = 0;\n    }\n\n    /**\n     * @method _updateTimeline\n     * @protected\n     */\n    _updateTimeline() {\n        let synched = this.mode !== MovieClip.INDEPENDENT;\n\n        if (synched) {\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\n            if (this.currentFrame >= this._totalFrames) {\n                this.currentFrame %= this._totalFrames;\n            }\n        }\n\n        if (this._prevPos === this.currentFrame) {\n            return;\n        }\n\n        // update timeline position, ignoring actions if this is a graphic.\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\n\n        this._prevPos = this.currentFrame;\n    }\n\n    /**\n     * Set the timeline position\n     * @method _setTimelinePostion\n     * @protected\n     * @param {int} startFrame\n     * @param {int} currentFrame\n     * @param {Boolean} doActions\n     */\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\n        //handle all tweens\n        let i, j, length, _timelines = this._timelines;\n        for (i = _timelines.length - 1; i >= 0; --i) {\n            let timeline = _timelines[i];\n            for (j = 0, length = timeline.length; j < length; ++j) {\n                let tween = timeline[j];\n                //if the tween contains part of the timeline that we are travelling through\n                if (currentFrame >= tween.startFrame &&\n                    currentFrame <= tween.endFrame) {\n                    // set the position within that tween\n                    //and break the loop to move onto the next timeline\n                    tween.setPosition(currentFrame);\n                    break;\n                }\n            }\n        }\n\n        let timedChildTimelines = this._timedChildTimelines;\n        let depthSorted = this._depthSorted;\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\n            let target = timedChildTimelines[i].target;\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\n            //if child should be on stage and is not:\n            if (shouldBeChild) {\n                // Add to the depthSorted object so we can\n                // check that items are property drawn later\n                depthSorted.push(target);\n                if (target.parent !== this) {\n                    // add the target if it's not there already\n                    this.addChild(target);\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\n                        target._reset();\n                    }\n                }\n            } else if (!shouldBeChild && target.parent === this) {\n                this.removeChild(target);\n            }\n        }\n\n        // Properly depth sort the children\n        for (i = 0, length = depthSorted.length; i < length; i++) {\n            let target = depthSorted[i];\n            let currentIndex = this.children.indexOf(target);\n            if (currentIndex !== i) {\n                this.addChildAt(target, i);\n            }\n        }\n\n        // Clear the temporary depth sorting array\n        depthSorted.length = 0;\n\n        //go through all children and update synched movieclips that are not single frames\n        let children = this.children,\n            child;\n        for (i = 0, length = children.length; i < length; ++i) {\n            child = children[i];\n            if (child.mode === MovieClip.SYNCHED) {\n                child._synchOffset = currentFrame - child.parentStartPosition;\n                child._updateTimeline();\n            }\n        }\n\n        //handle actions\n        if (doActions) {\n            let actions = this._actions;\n            //handle looping around\n            let needsLoop = false;\n            if (currentFrame < startFrame) {\n                length = actions.length;\n                needsLoop = true;\n            } else {\n                length = Math.min(currentFrame + 1, actions.length);\n            }\n            for (i = startFrame >= 0 ? startFrame + 1 : currentFrame; i < length; ++i) {\n                if (actions[i]) {\n                    let frameActions = actions[i];\n                    for (j = 0; j < frameActions.length; ++j) {\n                        frameActions[j].call(this);\n                    }\n                }\n                //handle looping around\n                if (needsLoop && i === length - 1) {\n                    i = 0;\n                    length = currentFrame + 1;\n                    needsLoop = false;\n                }\n            }\n        }\n    }\n\n    destroy(destroyChildren) {\n        if (this._tickListener) {\n            SharedTicker.remove(this._tickListener);\n            this._tickListener = null;\n        }\n        this._actions = null;\n        this._timelines = null;\n        this._depthSorted = null;\n        this._timedChildTimelines = null;\n        super.destroy(destroyChildren);\n    }\n}\n\n/**\n * The MovieClip will advance independently of its parent, even if its parent is paused.\n * This is the default mode.\n * @property INDEPENDENT\n * @static\n * @type String\n * @default 0\n * @readonly\n */\nMovieClip.INDEPENDENT = 0;\n\n/**\n * The MovieClip will only display a single frame (as determined by the startPosition property).\n * @property SINGLE_FRAME\n * @static\n * @type String\n * @default 1\n * @readonly\n */\nMovieClip.SINGLE_FRAME = 1;\n\n/**\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n * the parent MovieClip.\n * @property SYNCHED\n * @static\n * @type String\n * @default 2\n * @readonly\n */\nMovieClip.SYNCHED = 2;\n\n/**\n * Extend a container\n * @method extend\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\n/**\n * Extend a container (alias for extend)\n * @method e\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\nMovieClip.extend = MovieClip.e = function(child) {\n    child.prototype = Object.create(MovieClip.prototype);\n    child.prototype.__parent = MovieClip.prototype;\n    child.prototype.constructor = child;\n    return child;\n};\n\n// Assign to namespace\nexport default MovieClip;",
    "import utils from './utils';\n\n/**\n * Contains the collection of graphics data\n * @namespace PIXI.animate\n * @class ShapesCache\n */\nconst ShapesCache = {};\n\n/**\n * Add an item or itesm to the cache\n * @method add\n * @static\n * @param {String} prop  The id of graphic or the map of graphics to add\n * @param {String|Array<Array>} items Collection of draw commands\n */\nObject.defineProperty(ShapesCache, 'add', {\n    enumerable: false,\n    value: function(prop, items) {\n\n        // Decode string to map of files\n        if (typeof items === \"string\") {\n            items = utils.deserializeShapes(items);\n        }\n\n        // Convert all hex string colors (animate) to int (pixi.js)\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i];\n            for (let j = 0; j < item.length; j++) {\n                let arg = item[j];\n                if (typeof arg === 'string' && arg[0] === '#') {\n                    item[j] = utils.hexToUint(arg);\n                }\n            }\n        }\n        ShapesCache[prop] = items;\n    }\n});\n\n\n/**\n * Get the graphic from cache\n * @method  fromCache\n * @static\n * @param  {String} id The cache id\n * @return {Array} Series of graphic draw commands\n */\nObject.defineProperty(ShapesCache, 'fromCache', {\n    enumerable: false,\n    value: function(id) {\n        return ShapesCache[id] || null;\n    }\n});\n\n/**\n * Remove the graphic from cache\n * @method  remove\n * @static\n * @param  {String|Object} id The cache id or map\n */\nObject.defineProperty(ShapesCache, 'remove', {\n    enumerable: false,\n    value: function(id) {\n        if (typeof id === \"object\") {\n            for (let name in id) {\n                ShapesCache.remove(name);\n            }\n            return;\n        }\n        if (ShapesCache[id]) {\n            ShapesCache[id].length = 0;\n            delete ShapesCache[id];\n        }\n    }\n});\n\n/**\n * Remove all graphics from cache\n * @method  removeAll\n * @static\n */\nObject.defineProperty(ShapesCache, 'removeAll', {\n    enumerable: false,\n    value: function() {\n        for (let id in ShapesCache) {\n            ShapesCache.remove(id);\n        }\n    }\n});\n\n// Assign to namespace\nexport default ShapesCache;",
    "import ShapesCache from './ShapesCache';\n\n/**\n * The middleware for PIXI's ResourceLoader to be able to \n * load Flash symbols such as graphics and images.\n * @namespace PIXI.animate\n * @class SymbolLoader\n */\nlet SymbolLoader = function() {\n    return function(resource, next) {\n        let url = resource.url;\n        let data = resource.data;\n\n        if (url.search(/\\.shapes\\.(json|txt)$/i) > -1) {\n            ShapesCache.add(resource.name, data);\n        } else if (data.nodeName && data.nodeName === 'IMG') {\n            // Add individual images to the texture cache by their\n            // short symbol name, not the URL\n            PIXI.Texture.addTextureToCache(\n                PIXI.Texture.fromFrame(url),\n                resource.name\n            );\n        }\n        next();\n    };\n};\n\n// Assign to the loader\nPIXI.loaders.Loader.addPixiMiddleware(SymbolLoader);\n\nexport default SymbolLoader;",
    "import Tween from './Tween';\n\n/**\n * The Timeline class represents a\n * @namespace PIXI.animate\n * @class Timeline\n * @param {PIXI.DisplayObject} Target The target for this string of tweens.\n * @extends Array\n * @constructor\n */\nconst Timeline = function(target) {\n    Array.call(this);\n\n    /**\n     * The target DisplayObject.\n     * @property {PIXI.DisplayObject} target\n     */\n    this.target = target;\n\n    /**\n     * Current properties in the tween, to make building the timeline more\n     * efficient.\n     * @property {Object} _currentProps\n     * @private\n     */\n    this._currentProps = {};\n};\n\nconst p = Timeline.prototype = Object.create(Array.prototype);\n\n/**\n * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the normal ticking system)\n * and managed by this timeline. Adding a tween to multiple timelines will result in unexpected behaviour.\n * @method addTween\n * @param tween The tween(s) to add. Accepts multiple arguments.\n * @return Tween The first tween that was passed in.\n */\np.addTween = function(properties, startFrame, duration, ease) {\n    this.extendLastFrame(startFrame - 1);\n    //ownership of startProps is passed to the new Tween - this object should not be reused\n    let startProps = {};\n    let prop;\n    //figure out what the starting values for this tween should be\n    for (prop in properties) {\n        //if we have already set that property in an earlier tween, use the ending value\n        if (this._currentProps.hasOwnProperty(prop)) {\n            startProps[prop] = this._currentProps[prop];\n        }\n        //otherwise, get the current value\n        else {\n            let startValue = startProps[prop] = this.getPropFromShorthand(prop);\n            //go through previous tweens to set the value so that when the timeline loops\n            //around, the values are set properly - having each tween know what came before\n            //allows us to set to a specific frame without running through the entire timeline\n            for (let i = this.length - 1; i >= 0; --i) {\n                this[i].startProps[prop] = startValue;\n                this[i].endProps[prop] = startValue;\n            }\n        }\n    }\n    //create the new Tween and add it to the list\n    let tween = new Tween(this.target, startProps, properties, startFrame, duration, ease);\n    this.push(tween);\n    //update starting values for the next tween - if tweened values included 'p', then Tween\n    //parsed that to add additional data that is required\n    Object.assign(this._currentProps, tween.endProps);\n};\n\n/**\n * Add a single keyframe that doesn't tween.\n * @method addKeyframe\n * @param {Object} properties The properties to set.\n * @param {int} startFrame The starting frame index.\n */\np.addKeyframe = function(properties, startFrame) {\n    this.extendLastFrame(startFrame - 1);\n    let startProps = Object.assign({}, this._currentProps, properties);\n    //create the new Tween and add it to the list\n    let tween = new Tween(this.target, startProps, null, startFrame, 0);\n    this.push(tween);\n    Object.assign(this._currentProps, tween.endProps);\n};\n\n/**\n * Extend the last frame of the tween.\n * @method extendLastFrame\n * @param {int} endFrame The ending frame index.\n */\np.extendLastFrame = function(endFrame) {\n    if (this.length) {\n        let prevTween = this[this.length - 1];\n        if (prevTween.endFrame < endFrame) {\n            if (prevTween.isTweenlessFrame) {\n                prevTween.endFrame = endFrame;\n            } else {\n                this.addKeyframe(\n                    this._currentProps,\n                    prevTween.endFrame + 1,\n                    endFrame - prevTween.endFrame + 1\n                );\n            }\n        }\n    }\n};\n\n/**\n * Get the value for a property\n * @method getPropFromShorthand\n * @param {string} prop\n */\np.getPropFromShorthand = function(prop) {\n    const target = this.target;\n    switch (prop) {\n        case 'x':\n            return target.position.x;\n        case 'y':\n            return target.position.y;\n        case 'sx':\n            return target.scale.x;\n        case 'sy':\n            return target.scale.y;\n        case 'kx':\n            return target.skew.x;\n        case 'ky':\n            return target.skew.y;\n        case 'r':\n            return target.rotation;\n        case 'a':\n            return target.alpha;\n        case 'v':\n            return target.visible;\n        case 'm':\n            return target.mask;\n            // case 't':\n            //   return target.tint;\n            //not sure if we'll actually handle graphics this way?\n            //g: return null;\n    }\n    return null;\n};\n\n// Assign to namespace\nexport default Timeline;",
    "/**\n * Provide timeline playback of movieclip\n * @namespace PIXI.animate\n * @class Tween\n * @constructor\n * @param {PIXI.animate.MovieClip} target The target to play\n * @param {Object} startProps The starting properties\n * @param {Object} endProps The ending properties\n * @param {int} duration Number oframes to tween\n * @param {Function} [ease] Ease function to use\n */\n\nclass Tween {\n\n    constructor(target, startProps, endProps, startFrame, duration, ease) {\n\n        /**\n         * target display object\n         * @property {Object} target\n         */\n        this.target = target;\n\n        /** \n         * properties at the start of the tween\n         * @property {Object} startProps\n         */\n        this.startProps = startProps;\n\n        /**\n         * properties at the end of the tween, as well as any properties that are set\n         * instead of tweened\n         * @property {Object} endProps\n         */\n        this.endProps = {};\n\n        /**\n         * duration of tween in frames. For a keyframe with no tweening, the duration will be 0.\n         * @property {int} duration\n         */\n        this.duration = duration;\n\n        /**\n         * The frame that the tween starts on\n         * @property {int} startFrame\n         */\n        this.startFrame = startFrame;\n\n        /**\n         * the frame that the tween ends on\n         * @property {int} endFrame\n         */\n        this.endFrame = startFrame + duration;\n\n        /**\n         * easing function to use, if any\n         * @property {Function} ease\n         */\n        this.ease = ease;\n\n        /**\n         * If we don't tween.\n         * @property {Boolean} isTweenlessFrame\n         */\n        this.isTweenlessFrame = !endProps;\n\n\n        let prop;\n        if (endProps) {\n            //make a copy to safely include any unchanged values from the start of the tween\n            for (prop in endProps) {\n                this.endProps[prop] = endProps[prop];\n            }\n        }\n\n        //copy in any starting properties don't change\n        for (prop in startProps) {\n            if (!this.endProps.hasOwnProperty(prop)) {\n                this.endProps[prop] = startProps[prop];\n            }\n        }\n    }\n\n    /**\n     * Set the current frame.\n     * @method setPosition\n     * @param {int} currentFrame\n     */\n    setPosition(currentFrame) {\n        //if this is a single frame with no tweening, or at the end of the tween, then\n        //just speed up the process by setting values\n        if (currentFrame >= this.endFrame) {\n            this.setToEnd();\n            return;\n        }\n\n        if (this.isTweenlessFrame) {\n            this.setToEnd();\n            return;\n        }\n\n        let time = (currentFrame - this.startFrame) / this.duration;\n        if (this.ease) {\n            time = this.ease(time);\n        }\n        let target = this.target;\n        let startProps = this.startProps;\n        let endProps = this.endProps;\n        for (let prop in endProps) {\n            let lerp = props[prop];\n            if (lerp) {\n                setPropFromShorthand(target, prop, lerp(startProps[prop], endProps[prop], time));\n            } else {\n                setPropFromShorthand(target, prop, startProps[prop]);\n            }\n        }\n    }\n\n    /**\n     * Set to the end position\n     * @method setToEnd\n     */\n    setToEnd() {\n        let endProps = this.endProps;\n        let target = this.target;\n        for (let prop in endProps) {\n            setPropFromShorthand(target, prop, endProps[prop]);\n        }\n    }\n}\n\n//standard tweening\nfunction lerpValue(start, end, t) {\n    return start + (end - start) * t;\n}\n\nconst props = {\n    //position\n    x: lerpValue,\n    y: lerpValue,\n    //scale\n    sx: lerpValue,\n    sy: lerpValue,\n    //skew\n    kx: lerpValue,\n    ky: lerpValue,\n    //rotation\n    r: lerpRotation,\n    //alpha\n    a: lerpValue,\n    //tinting\n    // t: lerpColor,\n    t: null,\n    //values to be set\n    v: null, //visible\n    c: null, //colorTransform\n    m: null, //mask\n    g: null //not sure if we'll actually handle graphics this way?\n};\n\n//split r, g, b into separate values for tweening\n/*function lerpColor(start, end, t)\n{\n    //split start color into components\n    let sR = start >> 16 & 0xFF;\n    let sG = start >> 8 & 0xFF;\n    let sB = start & 0xFF;\n    //split end color into components\n    let eR = end >> 16 & 0xFF;\n    let eG = end >> 8 & 0xFF;\n    let eB = end & 0xFF;\n    //lerp red\n    let r = sR + (eR - sR) * percent;\n    //clamp red to valid values\n    if (r < 0)\n        r = 0;\n    else if (r > 255)\n        r = 255;\n    //lerp green\n    let g = sG + (eG - sG) * percent;\n    //clamp green to valid values\n    if (g < 0)\n        g = 0;\n    else if (g > 255)\n        g = 255;\n    //lerp blue\n    let b = sB + (eB - sB) * percent;\n    //clamp blue to valid values\n    if (b < 0)\n        b = 0;\n    else if (b > 255)\n        b = 255;\n\n    let combined = (r << 16) | (g << 8) | b;\n    return combined;\n}*/\n\nconst PI = Math.PI;\nconst TWO_PI = PI * 2;\n\n//handle 355 -> 5 degrees only going through a 10 degree change instead of\n//the long way around\n//Math from http://stackoverflow.com/a/2708740\nfunction lerpRotation(start, end, t) {\n    let difference = Math.abs(end - start);\n    if (difference > PI) {\n        // We need to add on to one of the values.\n        if (end > start) {\n            // We'll add it on to start...\n            start += TWO_PI;\n        } else {\n            // Add it on to end.\n            end += PI + TWO_PI;\n        }\n    }\n\n    // Interpolate it.\n    let value = (start + ((end - start) * t));\n\n    // wrap to 0-2PI\n    /*if (value >= 0 && value <= TWO_PI)\n        return value;\n    return value % TWO_PI;*/\n\n    //just return, as it's faster\n    return value;\n}\n\nfunction setPropFromShorthand(target, prop, value) {\n    switch (prop) {\n        case \"x\":\n            target.position.x = value;\n            break;\n        case \"y\":\n            target.position.y = value;\n            break;\n        case \"sx\":\n            target.scale.x = value;\n            break;\n        case \"sy\":\n            target.scale.y = value;\n            break;\n        case \"kx\":\n            target.skew.x = value;\n            break;\n        case \"ky\":\n            target.skew.y = value;\n            break;\n        case \"r\":\n            target.rotation = value;\n            break;\n        case \"a\":\n            target.alpha = value;\n            break;\n        case \"t\":\n            target.i(value); // i = setTint\n            break;\n        case \"c\":\n            target.c.apply(target, value); // c = setColorTransform\n            break;\n        case \"v\":\n            target.visible = value;\n            break;\n        case \"m\":\n            target.ma(value);\n            break;\n    }\n}\n\n// Assign to namespace\nexport default Tween;",
    "import load from './load';\nimport utils from './utils';\nimport MovieClip from './MovieClip';\nimport ShapesCache from './ShapesCache';\nimport SymbolLoader from './SymbolLoader';\nimport Timeline from './Timeline';\nimport Tween from './Tween';\nimport Animator from './Animator';\nimport AnimatorTimeline from './AnimatorTimeline';\n\nexport default {\n    Animator,\n    AnimatorTimeline,\n    load,\n    utils,\n    MovieClip,\n    ShapesCache,\n    SymbolLoader,\n    Timeline,\n    Tween\n};",
    "/**\n * @namespace PIXI.animate\n * @class load\n * @description Entry point for loading Adobe Animate exports:\n * \n * **Load and auto-add to parent**\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, stage);\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * **Load and handle with callback**\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, function(instance){\n *     stage.addChild(instance);\n * });\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n */\n/**\n * Load the stage class and preload any assets\n * @method load\n * @param {Object} options Options for loading.\n * @param {Function} options.stage Reference to the stage class\n * @param {Object} [options.stage.assets] Assets used to preload\n * @param {PIXI.Container} options.parent The Container to auto-add the stage to.\n * @param {String} [options.basePath] Base root directory\n */\n/**\n * Load the stage class and preload any assets\n * @method load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {Function} complete The callback function when complete.\n */\n/**\n * Load the stage class and preload any assets\n * @method load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\n */\nconst load = function(options, parent, complete, basePath) {\n\n    // Support arguments (ref, complete, basePath)\n    if (typeof parent === \"function\") {\n        basePath = complete;\n        complete = parent;\n        parent = null;\n    } else {\n        if (typeof complete === \"string\") {\n            basePath = complete;\n            complete = null;\n        }\n    }\n\n    if (typeof options === \"function\") {\n        options = {\n            stage: options,\n            parent: parent,\n            basePath: basePath || \"\",\n            complete: complete\n        };\n    }\n\n    options = Object.assign({\n        stage: null,\n        parent: null,\n        basePath: '',\n        complete: null\n    }, options || {});\n\n    const loader = new PIXI.loaders.Loader();\n\n    function done() {\n        let instance = new options.stage();\n        if (options.parent) {\n            options.parent.addChild(instance);\n        }\n        if (options.complete) {\n            options.complete(instance);\n        }\n    }\n\n    // Check for assets to preload\n    let assets = options.stage.assets || {};\n    if (assets && Object.keys(assets).length) {\n        // assetBaseDir can accept either with trailing slash or not\n        let basePath = options.basePath;\n        if (basePath) {\n            basePath += \"/\";\n        }\n        for (let id in assets) {\n            loader.add(id, basePath + assets[id]);\n        }\n        loader.once('complete', done).load();\n    } else {\n        // tiny case where there's only text and no shapes/animations\n        done();\n    }\n};\n\nexport default load;",
    "// If the movieclip plugin is installed\nlet _prepare = null;\n\n/**\n * @namespace PIXI.animate\n * @class utils\n * @private\n * @description For keyframe conversions\n */\nexport default class AnimateUtils {\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @method hexToUint\n     */\n    static hexToUint(hex) {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3) {\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\n        }\n        return parseInt(hex, 16);\n    }\n\n    /** \n     * Fill frames with booleans of true (showing) and false (hidden).\n     * @static\n     * @method fillFrames\n     * @param {Array<Boolean>} timeline\n     * @param {int} startFrame The start frame when the timeline shows up\n     * @param {int} duration The length of showing\n     */\n    static fillFrames(timeline, startFrame, duration) {\n        //ensure that the timeline is long enough\n        const oldLength = timeline.length;\n        if (oldLength < startFrame + duration) {\n            timeline.length = startFrame + duration;\n            //fill any gaps with false to denote that the child should be removed for a bit\n            if (oldLength < startFrame) {\n                //if the browser has implemented the ES6 fill() function, use that\n                if (timeline.fill) {\n                    timeline.fill(false, oldLength, startFrame);\n                } else {\n                    //if we can't use fill, then do a for loop to fill it\n                    for (let i = oldLength; i < startFrame; ++i) {\n                        timeline[i] = false;\n                    }\n                }\n            }\n        }\n        //if the browser has implemented the ES6 fill() function, use that\n        if (timeline.fill) {\n            timeline.fill(true, startFrame, startFrame + duration);\n        } else {\n            const length = timeline.length;\n            //if we can't use fill, then do a for loop to fill it\n            for (let i = startFrame; i < length; ++i) {\n                timeline[i] = true;\n            }\n        }\n    }\n\n    /**\n     * Convert serialized array into keyframes\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\n     * @static\n     * @method deserializeKeyframes\n     * @param {String} keyframes\n     * @param {Object} Resulting keyframes\n     */\n    static deserializeKeyframes(keyframes) {\n        let result = {};\n        let i = 0;\n        let keysMap = {\n            X: 'x', // x position\n            Y: 'y', // y position\n            A: 'sx', // scale x\n            B: 'sy', // scale y\n            C: 'kx', // skew x\n            D: 'ky', // skew y\n            R: 'r', // rotation\n            L: 'a', // alpha\n            T: 't', // tint\n            F: 'c', // colorTransform\n            V: 'v' // visibility\n        };\n        let c,\n            buffer = '',\n            isFrameStarted = false,\n            prop,\n            frame = {};\n\n        while (i <= keyframes.length) {\n            c = keyframes[i];\n            if (keysMap[c]) {\n                if (!isFrameStarted) {\n                    isFrameStarted = true;\n                    result[buffer] = frame;\n                }\n                if (prop) {\n                    frame[prop] = this.parseValue(prop, buffer);\n                }\n                prop = keysMap[c];\n                buffer = '';\n                i++;\n            }\n            // Start a new prop\n            else if (!c || c === ' ') {\n                i++;\n                frame[prop] = this.parseValue(prop, buffer);\n                buffer = '';\n                prop = null;\n                frame = {};\n                isFrameStarted = false;\n            } else {\n                buffer += c;\n                i++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\n     * @static\n     * @method deserializeShapes\n     * @param {String} str\n     * @param {Array} Resulting shapes map\n     */\n    static deserializeShapes(str) {\n        const result = [];\n        // each shape is a new line\n        let shapes = str.split(\"\\n\");\n        let isCommand = /^[a-z]{1,2}$/;\n        for (let i = 0; i < shapes.length; i++) {\n            let shape = shapes[i].split(' '); // arguments are space separated\n            for (let j = 0; j < shape.length; j++) {\n                // Convert all numbers to floats, ignore colors\n                let arg = shape[j];\n                if (arg[0] !== '#' && !isCommand.test(arg)) {\n                    shape[j] = parseFloat(arg);\n                }\n            }\n            result.push(shape);\n        }\n        return result;\n    }\n\n    /** \n     * Parse the value of the compressed keyframe.\n     * @method parseValue\n     * @static\n     * @private\n     * @param {String} prop The property key\n     * @param {String} buffer The contents\n     * @return {*} The parsed value\n     */\n    static parseValue(prop, buffer) {\n        switch (prop) {\n            // Color transforms are parsed as an array\n            case 'c':\n                {\n                    buffer = buffer.split(',');\n                    buffer.forEach(function(val, i, buffer) {\n                        buffer[i] = parseFloat(val);\n                    });\n                    return buffer;\n                }\n                // Tint value should not be converted\n                // can be color uint or string\n            case 't':\n                {\n                    return buffer;\n                }\n                // The visiblity parse as boolean\n            case 'v':\n                {\n                    return !!parseInt(buffer);\n                }\n                // Everything else parse a floats\n            default:\n                {\n                    return parseFloat(buffer);\n                }\n        }\n    }\n\n    /** \n     * Upload all the textures and graphics to the GPU. \n     * @method upload\n     * @static\n     * @param {PIXI.WebGLRenderer} renderer Render to upload to\n     * @param {PIXI.DisplayObject} clip MovieClip to upload\n     * @param {function} done When complete\n     */\n    static upload(renderer, displayObject, done) {\n        if (!_prepare) {\n            _prepare = renderer.plugins.prepare;\n            _prepare.register(this.addMovieClips);\n        }\n        _prepare.upload(displayObject, done);\n    }\n\n    /**\n     * Add movie clips to the upload prepare.\n     * @method addMovieClips\n     * @static\n     * @private\n     * @param {*} item To add to the queue \n     */\n    static addMovieClips(item) {\n        if (item instanceof PIXI.animate.MovieClip) {\n            item._timedChildTimelines.forEach((timeline) => {\n                const index = item.children.indexOf(timeline.target);\n                if (index === -1) {\n                    _prepare.add(timeline.target);\n                }\n            });\n            return true;\n        }\n        return false;\n    }\n}",
    "/**\n * @class Container\n * @namespace PIXI\n */\nconst p = PIXI.Container.prototype;\n\n/**\n * Shortcut for addChild.\n * @method ac\n * @param {*} [child*] N-number of children\n * @return {PIXI.DisplayObject} Instance of first child added\n */\np.ac = p.addChild;\n\n/**\n * Extend a container\n * @method extend\n * @static\n * @param {PIXI.Container} child The child function\n * @return {PIXI.Container} THe child\n */\n/**\n * Extend a container (shortcut for extend)\n * @method e\n * @static\n * @param {PIXI.Container} child The child function\n * @return {PIXI.Container} THe child\n */\nPIXI.Container.extend = PIXI.Container.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};",
    "import utils from '../animate/utils';\n\n/**\n * @namespace PIXI\n * @class DisplayObject\n */\nconst p = PIXI.DisplayObject.prototype;\n\n// Color Matrix filter\nlet ColorMatrixFilter;\nif (PIXI.filters) {\n    ColorMatrixFilter = PIXI.filters.ColorMatrixFilter;\n}\n\n/**\n * Function to see if this is renderable or not. Useful for setting masks.\n * @method setRenderable\n * @param  {Boolean} [renderable=false] Make renderable\n * @return {PIXI.DisplayObject}\n */\n/**\n * Shortcut to setRenderable.\n * @method re\n * @param  {Boolean} [renderable=false] Make renderable\n * @return {PIXI.DisplayObject}\n */\np.setRenderable = p.re = function(renderable) {\n    this.renderable = !!renderable;\n    return this;\n};\n\n/**\n * Shortcut for setTransform.\n * @method tr\n * @param {Number} x The X position\n * @param {Number} y The Y position\n * @param {Number} scaleX The X Scale value\n * @param {Number} scaleY The Y Scale value\n * @param {Number} skewX The X skew value\n * @param {Number} skewY The Y skew value\n * @param {Number} pivotX The X pivot value\n * @param {Number} pivotY The Y pivot value\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.t = p.setTransform;\n\n/**\n * Setter for mask to be able to chain.\n * @method setMask\n * @param {PIXI.Graphics} mask The mask shape to use\n * @return {PIXI.DisplayObject} Instance for chaining\n */\n/**\n * Shortcut for setMask.\n * @method ma\n * @param {PIXI.Sprite|PIXI.Graphics} mask The mask shape to use\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.setMask = p.ma = function(mask) {\n    // According to PIXI, only Graphics and Sprites can \n    // be used as mask, let's ignore everything else, like other\n    // movieclips and displayobjects/containers\n    if (mask) {\n        if (!(mask instanceof PIXI.Graphics) && !(mask instanceof PIXI.Sprite)) {\n            if (typeof console !== \"undefined\" && console.warn) {\n                console.warn(\"Warning: Masks can only be PIXI.Graphics or PIXI.Sprite objects.\");\n            }\n            return;\n        }\n    }\n    this.mask = mask;\n    return this;\n};\n\n/**\n * Setter for the alpha\n * @method setAlpha\n * @param {Number} alpha The alpha amount to use, from 0 to 1\n * @return {PIXI.DisplayObject} Instance for chaining\n */\n/**\n * Shortcut for setAlpha.\n * @method a\n * @param {Number} alpha The alpha amount to use, from 0 to 1\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.setAlpha = p.a = function(alpha) {\n    this.alpha = alpha;\n    return this;\n};\n\n/**\n * Set the tint values by color.\n * @method setTint\n * @param {int} tint The color value to tint\n * @return {PIXI.DisplayObject} Object for chaining\n */\n/**\n * Shortcut to setTint.\n * @method tn\n * @param {Number|String} tint The red percentage value\n * @return {PIXI.DisplayObject} Object for chaining\n */\np.setTint = p.i = function(tint) {\n    if (typeof tint === \"string\") {\n        tint = utils.hexToUint(tint);\n    }\n    // this.tint = tint\n    // return this;\n    // TODO: Replace with DisplayObject.tint setter\n    // once the functionality is added to Pixi.js, for\n    // now we'll use the slower ColorMatrixFilter to handle\n    // the color transformation\n    var r = tint >> 16 & 0xFF;\n    var g = tint >> 8 & 0xFF;\n    var b = tint & 0xFF;\n    return this.c(r / 255, 0, g / 255, 0, b / 255, 0);\n};\n\n/**\n * Set additive and multiply color, tinting\n * @method setColorTransform\n * @param {Number} r The multiply red value\n * @param {Number} rA The additive red value\n * @param {Number} g The multiply green value\n * @param {Number} gA The additive green value\n * @param {Number} b The multiply blue value\n * @param {Number} bA The additive blue value\n * @return {PIXI.DisplayObject} Object for chaining\n */\n/**\n * Shortcut to setColor.\n * @method c\n * @param {Number} r The multiply red value\n * @param {Number} rA The additive red value\n * @param {Number} g The multiply green value\n * @param {Number} gA The additive green value\n * @param {Number} b The multiply blue value\n * @param {Number} bA The additive blue value\n * @return {PIXI.DisplayObject} Object for chaining\n */\np.setColorTransform = p.c = function(r, rA, g, gA, b, bA) {\n    var filter = this.colorTransformFilter;\n    filter.matrix[0] = r;\n    filter.matrix[4] = rA;\n    filter.matrix[6] = g;\n    filter.matrix[9] = gA;\n    filter.matrix[12] = b;\n    filter.matrix[14] = bA;\n    this.filters = [filter];\n    return this;\n};\n\n/**\n * The current default color transforming filters\n * @property {PIXI.filters.ColorMatrixFilter} colorTransformFilter\n */\nif (!p.hasOwnProperty('colorTransformFilter')) {\n    Object.defineProperty(p, 'colorTransformFilter', {\n        set: function(filter) {\n            this._colorTransformFilter = filter;\n        },\n        get: function() {\n            return this._colorTransformFilter || new ColorMatrixFilter();\n        }\n    });\n}\n\n/**\n * Extend a container\n * @method extend\n * @static\n * @param {PIXI.DisplayObject} child The child function\n * @return {PIXI.DisplayObject} THe child\n */\n/**\n * Extend a container (shortcut for extend)\n * @method e\n * @static\n * @param {PIXI.DisplayObject} child The child function\n * @return {PIXI.DisplayObject} THe child\n */\nPIXI.DisplayObject.extend = PIXI.DisplayObject.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};",
    "/**\n * @namespace PIXI\n * @class Graphics\n */\nconst p = PIXI.Graphics.prototype;\n\n/**\n * Shortcut for drawCommands.\n * @method d\n * @param  {Array} commands The commands and parameters to draw\n * @return {PIXI.Graphics}\n */\n/**\n * Execute a series of commands, this is the name of the short function\n * followed by the parameters, e.g., `[\"f\", \"#ff0000\", \"r\", 0, 0, 100, 200]`\n * @method drawCommands\n * @param  {Array} commands The commands and parameters to draw\n * @return {PIXI.Graphics}\n */\np.drawCommands = p.d = function(commands) {\n    var currentCommand, params = [],\n        i = 0;\n\n    while (i <= commands.length) {\n        var item = commands[i++];\n        if (item === undefined || this[item]) {\n            if (currentCommand) {\n                this[currentCommand].apply(this, params);\n                params.length = 0;\n            }\n            currentCommand = item;\n        } else {\n            params.push(item);\n        }\n    }\n    return this;\n};\n\n/**\n * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n * since the fill or stroke was last set.\n * @method c\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.c = p.closePath;\n\n/**\n * Alias for addHole\n * @method h\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.h = p.addHole;\n\n/**\n * Shortcut to moveTo.\n * @method m\n * @param {Number} x The x coordinate the drawing point should move to.\n * @param {Number} y The y coordinate the drawing point should move to.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls).\n **/\np.m = p.moveTo;\n\n/**\n * Shortcut to lineTo.\n * @method l\n * @param {Number} x The x coordinate the drawing point should draw to.\n * @param {Number} y The y coordinate the drawing point should draw to.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.l = p.lineTo;\n\n/**\n * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n * whatwg spec</a>. A tiny API method \"qt\" also exists.\n * @method q\n * @param {Number} cpx\n * @param {Number} cpy\n * @param {Number} x\n * @param {Number} y\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.q = p.quadraticCurveTo;\n\n/**\n * Shortcut to bezierCurveTo.\n * @method b\n * @param {Number} cp1x\n * @param {Number} cp1y\n * @param {Number} cp2x\n * @param {Number} cp2y\n * @param {Number} x\n * @param {Number} y\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.b = p.bezierCurveTo;\n\n/**\n * Shortcut to beginFill.\n * @method f\n * @param {Uint} color The hex color value (e.g. 0xFFFFFF)\n * null will result in no fill.\n * @param {Number} [alpha=1] The alpha value of fill\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.f = p.beginFill;\n\n/**\n * Shortcut to lineStyle.\n * @method s\n * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n * null will result in no stroke.\n * @param {Number} [thickness=1] The thickness of the stroke\n * @param {Number} [alpha=1] The alpha value from 0 (invisibile) to 1 (visible)\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.s = p.lineStyle;\n\n/**\n * Shortcut to drawRect.\n * @method dr\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\n/**\n * Shortcut to drawRect.\n * @method r\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.dr = p.drawRect;\n\n/**\n * Shortcut to drawRoundedRect.\n * @method rr\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @param {Number} radius The corner radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rr = p.drawRoundedRect;\n\n/**\n * Shortcut to drawRoundedRect.\n * @method rc\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @param {Number} radiusTL The top left corner radius\n * @param {Number} radiusTR The top right corner radius\n * @param {Number} radiusBR The bottom right corner radius\n * @param {Number} radiusBL The bottom left corner radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rc = p.drawRoundedRect;\n\n/**\n * Shortcut to drawCircle.\n * @method dc\n * @param {Number} x x coordinate center point of circle.\n * @param {Number} y y coordinate center point of circle.\n * @param {Number} radius Radius of circle.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.dc = p.drawCircle;\n\n/**\n * Shortcut to arc.\n * @method ac\n * @param {Number} x\n * @param {Number} y\n * @param {Number} radius\n * @param {Number} startAngle Measured in radians.\n * @param {Number} endAngle Measured in radians.\n * @param {Boolean} anticlockwise\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.ar = p.arc;\n\n/**\n * Shortcut to arcTo.\n * @method at\n * @param {Number} x1\n * @param {Number} y1\n * @param {Number} x2\n * @param {Number} y2\n * @param {Number} radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.at = p.arcTo;\n\n/**\n * Shortcut to drawEllipse.\n * @method  de\n * @param  {Number} x      [description]\n * @param  {Number} y      [description]\n * @param  {Number} width  [description]\n * @param  {Number} height [description]\n */\np.de = p.drawEllipse;\n\n/**\n * Placeholder method for a linear fill. Pixi does not support linear fills,\n * so we just pick the first color in colorArray\n * @method lf\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.lf = function(colorArray) {\n    // @if DEBUG\n    console.warn(\"Linear gradient fills are not supported\");\n    // @endif\n    return this.f(colorArray[0]);\n};\n\n/**\n * Placeholder method for a radial fill. Pixi does not support radial fills,\n * so we just pick the first color in colorArray\n * @method rf\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rf = function(colorArray) {\n    // @if DEBUG\n    console.warn(\"Radial gradient fills are not supported\");\n    // @endif\n    return this.f(colorArray[0]);\n};\n\n/**\n * Placeholder method for a beginBitmapFill. Pixi does not support bitmap fills.\n * @method bf\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.bf = function() {\n    // @if DEBUG\n    console.warn(\"Bitmap fills are not supported\");\n    // @endif\n    return this.f(0x0);\n};\n\n/**\n * Placeholder method for a setStrokeDash. Pixi does not support dashed strokes.\n * @method sd\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.sd = function() {\n    // @if DEBUG\n    console.warn(\"Dashed strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a beginBitmapStroke. Pixi does not support bitmap strokes.\n * @method bs\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.bs = function() {\n    // @if DEBUG\n    console.warn(\"Bitmap strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a beginLinearGradientStroke. Pixi does not support gradient strokes.\n * @method ls\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.ls = function() {\n    // @if DEBUG\n    console.warn(\"Linear gradient strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a beginRadialGradientStroke. Pixi does not support gradient strokes.\n * @method rs\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rs = function() {\n    // @if DEBUG\n    console.warn(\"Radial gradient strokes are not supported\");\n    // @endif\n    return this;\n};",
    "/**\n * @namespace PIXI\n * @class Sprite\n */\nconst p = PIXI.Sprite.prototype;\n\n/**\n * Extend a container\n * @method extend\n * @static\n * @param {PIXI.Sprite} child The child function\n * @return {PIXI.Sprite} THe child\n */\n/**\n * Extend a container (shortcut for extend)\n * @method e\n * @static\n * @param {PIXI.Sprite} child The child function\n * @return {PIXI.Sprite} THe child\n */\nPIXI.Sprite.extend = PIXI.Sprite.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};",
    "/**\n * @namespace PIXI\n * @class Text\n */\nconst p = PIXI.Text.prototype;\n\n/**\n * Setter for the alignment, also sets the anchor point\n * to make sure the positioning is correct.\n * @method setAlign\n * @param {String} align Either, center, right, left\n * @return {PIXI.Text} For chaining\n */\n/**\n * Shortcut for `setAlign`.\n * @method g\n * @param {String|int} align Either, center (0), right (1), left (-1)\n * @return {PIXI.Text} For chaining\n */\np.setAlign = p.g = function(align) {\n    this.style.align = align || \"left\";\n    var x;\n    if (typeof align == \"string\") {\n        switch (align) {\n            case \"center\":\n                x = 0.5;\n                break;\n            case \"right\":\n                x = 1;\n                break;\n            case \"left\":\n                x = 0;\n                break;\n        }\n    } else {\n        x = (align + 1) / 2;\n    }\n    this.anchor.x = x;\n    return this;\n};\n\n// Map of short names to long names\nvar STYLE_PROPS = {\n    o: 'font', // TODO: deprecate in Pixi v4\n    z: 'fontSize',\n    f: 'fontFamily',\n    y: 'fontStyle',\n    g: 'fontWeight',\n    i: 'fill',\n    a: 'align',\n    s: 'stroke',\n    t: 'strokeThickness',\n    w: 'wordWrap',\n    d: 'wordWrapWidth',\n    l: 'lineHeight',\n    h: 'dropShadow',\n    c: 'dropShadowColor',\n    n: 'dropShadowAngle',\n    b: 'dropShadowBlur',\n    p: 'padding',\n    x: 'textBaseline',\n    j: 'lineJoin',\n    m: 'miterLimit',\n    e: 'letterSpacing'\n};\n\n/**\n * Set the style, a chainable version of style setter\n * @method setStyle\n * @param {Object} style\n * @return {PIXI.Text} instance of text field\n */\n/**\n * Shortcut for `setStyle`.\n * @method ss\n * @param {Object} style\n * @return {PIXI.Text} instance of text field\n */\np.setStyle = p.ss = function(style) {\n    // Replace short STYLE_PROPS with long names\n    for (var k in STYLE_PROPS) {\n        if (style[k] !== undefined) {\n            style[STYLE_PROPS[k]] = style[k];\n            delete style[k];\n        }\n    }\n    this.style = style;\n    return this;\n};\n\n/**\n * Initial setting of the drop shadow.\n * @method setShadow\n * @param {String} [color=\"#000000\"] The color to set\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\n * @param {Number} [distance=5] The offset distance\n * @return {PIXI.Text} For chaining\n */\n/**\n * Shortcut for setShadow.\n * @method sh\n * @param {String} [color=\"#000000\"] The color to set\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\n * @param {Number} [distance=5] The offset distance\n * @return {PIXI.Text} For chaining\n */\np.setShadow = p.sh = function(color, angle, distance) {\n    var style = this.style;\n    style.dropShadow = true;\n\n    // Convert color to hex string\n    if (color !== undefined) {\n        color = \"#\" + color.toString(16);\n    }\n    style.dropShadowColor = isUndefinedOr(color, style.dropShadowColor);\n    style.dropShadowAngle = isUndefinedOr(angle, style.dropShadowAngle);\n    style.dropShadowDistance = isUndefinedOr(distance, style.dropShadowDistance);\n    return this;\n};\n\n/**\n * Check if a value is undefined, fallback to default value\n * @method isUndefinedOr \n * @private\n * @param {*} value The value to check\n * @param {*} defaultValue The default value if value is undefined\n * @return {*} The either the value or the default value\n */\nvar isUndefinedOr = function(value, defaultValue) {\n    return value === undefined ? defaultValue : value;\n};",
    "import Container from './Container';\nimport DisplayObject from './DisplayObject';\nimport Sprite from './Sprite';\nimport Graphics from './Graphics';\nimport Text from './Text';\n\nexport default {\n    Container,\n    DisplayObject,\n    Sprite,\n    Graphics,\n    Text\n};",
    "// Export for Node-compatible environments like Electron\nif (typeof module !== 'undefined' && module.exports) {\n    // Attempt to require the pixi module\n    if (typeof PIXI === 'undefined') {\n\n        // Solution for Atom/Electron to work around\n        // the V8 restriction on using unsafe-eval code\n        // this solution is taken from the loophole module.\n        // under the hood this use's node's vm module.\n        if (typeof atom !== \"undefined\") {\n            global.Function = require('loophole').Function;\n        }\n\n        // Include the Pixi.js module\n        // @if DEBUG\n        require('./pixi.js');\n        // @endif\n        // @if RELEASE\n        require('./pixi.min.js');\n        // @endif\n    }\n\n    // Export the module\n    module.exports = require('./animate').default;\n}\n// If we're in the browser make sure PIXI is available\nelse if (typeof PIXI === 'undefined') {\n    throw \"Requires PIXI\";\n}\n\n// Include the PIXI mixins\nrequire('./mixins');\n\n// Assign to global namespace\nPIXI.animate = require('./animate').default;\nPIXI.animate.VERSION = '/* @echo VERSION */' || '';"
  ]
}